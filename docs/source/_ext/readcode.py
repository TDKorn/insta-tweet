import os
import re
import shutil

# ~~~~~~~~ My Own Thing (replace_autodoc_refs_with_linkcode) ~~~~~~~~~
#
# Directory to save temp .rst file to while docs building
#
# if on_rtd:
#     rst_build_dir = os.path.abspath('../_build/')
# else:
rst_build_dir = os.path.abspath('../build/')
print(rst_build_dir)
#
#
# Source file to convert for GitHub README/PyPi description
#
rst_src = os.path.abspath('_readme/about-instatweet.rst')
#
# File to save the final converted output to
#
rst_out = os.path.abspath('../../README.rst')  # Root of the repository
#
# [Optional] dict of {'ref': 'external_link'} to replace relative links
# like :ref:`ref` with an `ref <external_link>`_ (ex. for PyPi)
#
rst_replace_refs = {
    'mandatory-settings': 'https://instatweet.readthedocs.io/en/latest/_readme/getting-started.html#mandatory-settings',
}


def replace_autodoc_refs_with_linkcode(info: dict, link: str, rst_src: str, rst_build_dir: str):
    """Replaces Sphinx autodoc cross-references in a .rst file with linkcode links to highlighted GitHub source code

    Essentially turns your GitHub README into Sphinx-like documentation contained fully within the repository


    =================================  By https://github.com/TDKorn  =====================================


    For example, :meth:`~.InstaClient.get_user` would be rendered in HTML as an outlined "get_user()" link
    that contains an internal reference to the corresponding documentation entry (assuming it exists)

    We love it, it's great. Fr. But it's ugly and useless on GitHub and PyPi. Literally so gross.

    This function replaces cross-references in the ``rst_src`` file with the links generated by linkcode,
    which take you to the source file and highlight the full definition of the class/method/function/target

    .. note:: links are of the format https://github.com/user/repo/blob/branch/package/file.py#L30-L35

        For example,
        `get_user() <https://github.com/TDKorn/insta-tweet/blob/docs/InstaTweet/instaclient.py#L42-L64>`_


    :param info: the info dict from linkcode_resolve
    :param link: link to the highlighted GitHub source code, generated by linkcode
    :param rst_src: the .rst file to use as the initial source of content
    :param rst_build_dir: the directory to use while building the docs
    """
    if not rst_src.endswith('.rst'):
        raise TypeError

    # On the first function call that actually replaces a cross-reference with a link,
    # the content from ``rst_src`` is copied and saved to a temporary rst file in ``rst_build_dir``
    #
    # All function calls afterwards will use this temp file as the source and output file
    # When the build completes, it will be moved to the specified ``rst_out`` location
    #
    rst_temp = os.path.join(rst_build_dir, os.path.basename(rst_src))

    # If the temp output file already exists, use it as the source, since
    # the content from ``rst_src`` is already copied to it (and possibly edited)
    if os.path.exists(rst_temp):
        rst_src = rst_temp

    else:
        # If not, it's the first function call. It needs to be created
        rst_src = os.path.abspath(rst_src)

        # And if the rst build directory doesn't exist, create it too
        if not os.path.exists(rst_build_dir):
            os.mkdir(rst_build_dir)

    # Read in the rst
    rst = read(rst_src)

    # Use the linkcode data that was provided to see what the reference target is
    # Ex:  Class.[method] // module.[function] // [function]
    ref_name = info['fullname'].split('.')[-1]

    # The rst could have :meth:`~.method` or :meth:`~.Class.method` or :class:`~.Class` or...
    # Regardless, there's :directive:`~[].target` where [] is optional
    pattern = rf":\w+:`~\.?\w?\.{ref_name}`"

    # See if there's any reference in the rst, and figure out what it is
    if match := re.findall(pattern, rst):
        directive = match[0].split(':')[1]
    else:
        print('No references found for', ref_name)
        return None

    # Format the name of methods
    if directive == 'meth':
        ref_name += "()"

    # Format the link -> `method() <https://www.github.com/.../file.py#L10-L19`_
    rst_link = f"`{ref_name} <{link}>`_"

    # Then take the link and sub that hoe in!!
    subbed_rst = re.sub(pattern, rst_link, rst)

    # Save to the temp build rst file
    with open(rst_temp, 'w', encoding='utf-8') as f:
        f.write(subbed_rst)

    print(f'Added reST links for {ref_name}: {rst_link}')
    return {'info': info, 'rst_link': rst_link}


# ---- Methods for "build-finished" Core Event ----------------------

def read(file):
    with open(os.path.abspath(file), 'r', encoding='utf-8') as f:
        return u'{}'.format(f.read())


def replace_rst_refs(rst: str, refs: dict) -> str:
    """Post-processes the generated rst, replacing :ref: with external links (ex. for PyPi)

    :param rst: the text of the .rst file
    :param refs: dict of {'reference': 'external_link'}
    :return: the processed rst text
    """
    for ref, external_link in refs.items():
        rst = re.sub(
            pattern=rf":ref:`{ref}`",
            repl=f"`{ref} <{external_link}>`_",
            string=rst
        )
    return rst


def replace_rst_images(rst: str, img_dir: str = "_static") -> str:
    """Post-processes the generated rst, replacing relative image paths with external RTD links

    Probably temporary until I write a proper function that adjusts the paths when moving to ``rst_out``

    :param img_dir:
    :param rst: the text of the .rst file
    :return: the processed rst text
    """
    return re.sub(
        #          .. image:: [img_dir][/](filename.png)|/(filename.jpeg)
        pattern=r".. image:: \S*[/](\w+\.\w{3,4})",
        repl=r".. image:: https://instatweet.readthedocs.io/en/latest/_images/\1",
        string=rst
    )


def post_process_rst_file(app, exception):
    """Moves the generated rst file from ``rst_temp`` to ``rst_out``"""
    built_rst = os.path.join(
        rst_build_dir, os.path.basename(rst_src)
    )
    if os.path.exists(built_rst):
        rst = replace_rst_images(rst=read(built_rst))
        if rst_replace_refs:
            rst = replace_rst_refs(rst, refs=rst_replace_refs)

        with open(built_rst, 'w', encoding='utf-8') as f:
            f.write(rst)

        shutil.move(built_rst, rst_out)
        return print(f'Generated .rst file: {rst_out}')

    if exception:
        return print(
            "No .rst file generated, exception raised:",
            exception, sep='\n'
        )
    return print('No .rst file generated, no exception was raised')


def setup(app):
    app.connect('build-finished', post_process_rst_file)
